<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>타임 프로파일링 하기 - Rust and WebAssembly</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> 소개</a></li><li class="chapter-item expanded "><a href="../why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 왜 Rust로 WebAssembly 개발을 해야 하나요?</a></li><li class="chapter-item expanded "><a href="../background-and-concepts.html"><strong aria-hidden="true">3.</strong> 배경 지식</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> WebAssembly가 뭔가요?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 튜토리얼</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 셋업하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="../game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 규칙</a></li><li class="chapter-item expanded "><a href="../game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> Game of Life 구현하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> Game of Life 테스팅하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> 디버깅</a></li><li class="chapter-item expanded "><a href="../game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> 상호작용 추가하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/time-profiling.html" class="active"><strong aria-hidden="true">4.8.</strong> 타임 프로파일링 하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="../game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> Publishing to npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/crates.html"><strong aria-hidden="true">5.1.</strong> Crates You Should Know</a></li><li class="chapter-item expanded "><a href="../reference/tools.html"><strong aria-hidden="true">5.2.</strong> Tools You Should Know</a></li><li class="chapter-item expanded "><a href="../reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> Project Templates</a></li><li class="chapter-item expanded "><a href="../reference/debugging.html"><strong aria-hidden="true">5.4.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="../reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> Time Profiling</a></li><li class="chapter-item expanded "><a href="../reference/code-size.html"><strong aria-hidden="true">5.6.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="../reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript Interoperation</a></li><li class="chapter-item expanded "><a href="../reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> Which Crates Will Work Off-the-Shelf with WebAssembly?</a></li><li class="chapter-item expanded "><a href="../reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> How to Add WebAssembly Support to a General-Purpose Crate</a></li><li class="chapter-item expanded "><a href="../reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Deploying Rust and WebAssembly to Production</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="타임-프로파일링-하기"><a class="header" href="#타임-프로파일링-하기">타임 프로파일링 하기</a></h1>
<p>이 챕터에서는 타임 프로파일링 작업을 해보면서 전에 구현한 Game of Life의 성능을 개선시켜보겠습니다.</p>
<p>시작하기 전에, <a href="../reference/time-profiling.html">Rust와 WebAssembly 코드에 사용해볼수 있는 타임 프로파일링 툴들</a>을 살펴보고 익숙해져 보세요.</p>
<h2 id="windowperformancenow-함수를-사용하여-초당-프레임-fps-frames-per-second-타이머-만들기"><a class="header" href="#windowperformancenow-함수를-사용하여-초당-프레임-fps-frames-per-second-타이머-만들기"><code>window.performance.now</code> 함수를 사용하여 초당 프레임 (FPS, Frames Per Second) 타이머 만들기</a></h2>
<p>이 FPS 타이머는 구현한 게임의 렌더링 속도를 어떻게 개선하는지 살펴볼 때 매우 유용하게 사용될 예정입니다.</p>
<p><code>wasm-game-of-life/www/index.js</code> 파일에 <code>fps</code> 객체를 추가하는 것으로 시작해봅시다:</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById("fps");
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // 마지막 프레임 렌더부터의 델타 시간을 fps 단위로 변환합니다.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // 마지막 100개의 타이밍만 저장합니다.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // 최대, 최소 타이밍과 마지막 100개 타이밍의 평균을 찾습니다.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // 통계를 렌더합니다.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<p><code>fps</code> 객체의 <code>render</code> 함수를 매 <code>renderLoop</code> 반복마다 불러보겠습니다:</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>마지막으로, <code>fps</code> 요소를 잊지 말고 <code>wasm-game-of-life/www/index.html</code> 파일에 추가해줍시다. <code>&lt;canvas&gt;</code> 바로 위에 추가해주세요:</p>
<pre><code class="language-html">&lt;div id="fps"&gt;&lt;/div&gt;
</code></pre>
<p>그리고 CSS 프로퍼티를 추가해서 깔끔하게 포맷해주겠습니다:</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>짜잔! 이제 <a href="http://localhost:8080">http://localhost:8080</a> 페이지를 새로고침 하면 FPS 카운터를 확인할 수 있게 됐습니다!</p>
<h3 id="universetick과-consoletime-consoletimeend-시간-측정하기"><a class="header" href="#universetick과-consoletime-consoletimeend-시간-측정하기"><code>Universe::tick</code>과 <code>console.time</code>, <code>console.timeEnd</code> 시간 측정하기</a></h3>
<p>각 <code>Universe::tick</code>이 호출되는데 시간이 얼마나 걸리는지 확인해볼려면 <code>web-sys</code> 크레이트의 <code>console.time</code>, <code>console.timeend</code> 를 활용해볼수 있습니다.</p>
<p>먼저, <code>wasm-game-of-life/Cargo.toml</code> 파일을 열고 <code>web-sys</code> 를 종속성으로 추가해주세요:</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
</code></pre>
<p><code>console.time</code>를 호출할 때 마다 <code>console.timeEnd</code>도 같이 호출될 예정이기 때문에, <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 타입으로 묶어서 간편하게 사용할수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>그 다음에, 메소드 최상단에 이 코드를 추가해서 얼마나 각 <code>Universe::tick</code> 호출이 오래 걸리는지 측정해볼수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _timer = Timer::new("Universe::tick");
<span class="boring">}</span></code></pre></pre>
<p>콘솔에 <code>Universe::tick</code>를 호출하는데 얼마나 오래 걸렸는지 로그를 표시합니다:</p>
<p><a href="../images/game-of-life/console-time.png"><img src="../images/game-of-life/console-time.png" alt="console.time 로그 스크린샷" /></a></p>
<p>추가로, 브라우저 프로파일러(profiler)의 timeline 혹은 waterfall 뷰에서 <code>console.time</code>과 <code>console.timeEnd</code>가 같이 실행된 부분을 확인할 수 있습니다:</p>
<p><a href="../images/game-of-life/console-time-in-profiler.png"><img src="../images/game-of-life/console-time-in-profiler.png" alt="console.time 로그 스크린샷" /></a></p>
<h2 id="game-of-life-세상의-사이즈-키워보기"><a class="header" href="#game-of-life-세상의-사이즈-키워보기">Game of Life 세상의 사이즈 키워보기</a></h2>
<blockquote>
<p>⚠️ 이 섹션은 FireFox의 스크린샷을 예시로 보여줍니다. 거의 모든 모던 브라우저가 비슷한 기능들을 가지고 있지만, 개발자 도구에 브라우저마다 약간의 차이가 있을 수 있습니다. 추출하게 될 프로파일 정보는 기본적으로 같지만, 보게 될 뷰나 도구 이름 등이 다를수 있는 점을 확인해주세요.</p>
</blockquote>
<p>구현한 Game of Life 세상을 더 크게 만들어보면 어떨까요? 64 x 64 사이즈의 세상을 128 x 128 사이즈로 늘려봅시다. (<code>wasm-game-of-life/src/lib.rs</code> 파일에서 <code>Universe::new</code>를 수정해주세요.) 사이즈를 늘리게 되면 부드럽게 작동하던 60fps 화면이 버벅이면서 40fps 처럼 보이는 것을 확인할수 있게 됩니다.</p>
<p>프로파일을 기록하고 waterfall 뷰를 확인하면, 각 애니메이션이 20 밀리초 이상 걸리는 것을 확인할 수 있습니다. 60fps로 작동했을 때 프레임 전체를 렌더하는데 16 밀리초가 걸린 것을 떠올려보면 확실히 차이가 있습니다. 참고로, JavaScript와 WebAssembly외에도 페이지를 그리는 등 브라우저가 수행하는 작업의 영향도 있습니다.</p>
<p><a href="../images/game-of-life/drawCells-before-waterfall.png"><img src="../images/game-of-life/drawCells-before-waterfall.png" alt="페이지 렌더링 처리의 waterfall 뷰 스크린샷" /></a></p>
<p>한 애니메이션 프레임동안 어떤 일이 일어나는지 확인해보면, <code>CanvasRenderingContext2D.fillStyle</code> setter가 성능 차원에서 많은 비용을 요구하는 것을 확인할 수 있습니다.</p>
<blockquote>
<p>⚠️ FireFox 브라우저에서 위에서 언급된 <code>CanvasRenderingContext2D.fillStyle</code> 대신에 "DOM"이 표시된다면, 성능 개발자 도구(performance developer tools)에서 "Gecko 플랫폼 데이터 표시하기 (Show Gecko Platform Data)" 옵션을 활성화해줘야 합니다:</p>
<p><a href="../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="&quot;Gecko 플랫폼 데이터 표시하기 (Show Gecko Platform Data)&quot; 옵션 활성화하기" /></a></p>
</blockquote>
<p><a href="../images/game-of-life/drawCells-before-flamegraph.png"><img src="../images/game-of-life/drawCells-before-flamegraph.png" alt="페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<p><a href="../images/game-of-life/drawCells-before-flamegraph.png"><img src="../images/game-of-life/drawCells-before-flamegraph.png" alt="페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<p>많이 표시되는 호출 트리의 집계(call tree's aggregation)를 살펴보면 이게 전혀 이상한 동작이 아님을 확인할 수 있습니다:</p>
<p><a href="../images/game-of-life/drawCells-before-calltree.png"><img src="../images/game-of-life/drawCells-before-calltree.png" alt="페이지 렌더링 처리의 flamegraph 뷰 스크린샷" /></a></p>
<p>거의 40% 분량을 이 setter에 사용해버렸네요!</p>
<blockquote>
<p>⚡ <code>tick</code> 메소드가 성능 병목을 일으키는데 특별한 이유가 있을 것 같았지만, 사실 그렇지 않은 부분을 확인했습니다. 작업을 하다 보면 예상치 못한 부분에서 시간을 많이 쓰게 될수도 있으니, 항상 프로파일링 도구를 먼저 살펴보도록 합시다.</p>
</blockquote>
<p><code>wasm-game-of-life/www/index.js</code> 파일 내의 <code>drawCells</code> 함수에서 <code>fillStyle</code> 프로퍼티가 한번 정해지고 세상 내의 모든 세포와 모든 애니메이션에 이 프로퍼티가 사용되게 됩니다.</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>Now that we have discovered that setting <code>fillStyle</code> is so expensive, what can
we do to avoid setting it so often? We need to change <code>fillStyle</code> depending on
whether a cell is alive or dead. If we set <code>fillStyle = ALIVE_COLOR</code> and then
draw every alive cell in one pass, and then set <code>fillStyle = DEAD_COLOR</code> and
draw every dead cell in another pass, then we only end setting <code>fillStyle</code>
twice, rather than once for every cell.</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>After saving these changes and refreshing
<a href="http://localhost:8080/">http://localhost:8080/</a>, rendering is back to a smooth
60 frames per second.</p>
<p>If we take another profile, we can see that only about ten milliseconds are
spent in each animation frame now.</p>
<p><a href="../images/game-of-life/drawCells-after-waterfall.png"><img src="../images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>Breaking down a single frame, we see that the <code>fillStyle</code> cost is gone, and most
of our frame's time is spent within <code>fillRect</code>, drawing each cell's rectangle.</p>
<p><a href="../images/game-of-life/drawCells-after-flamegraph.png"><img src="../images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<h2 id="making-time-run-faster"><a class="header" href="#making-time-run-faster">Making Time Run Faster</a></h2>
<p>Some folks don't like waiting around, and would prefer if instead of one tick of
the universe occurred per animation frame, nine ticks did. We can modify the
<code>renderLoop</code> function in <code>wasm-game-of-life/www/index.js</code> to do this quite
easily:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>On my machine, this brings us back down to only 35 frames per second. No
good. We want that buttery 60!</p>
<p>Now we know that time is being spent in <code>Universe::tick</code>, so let's add some
<code>Timer</code>s to wrap various bits of it in <code>console.time</code> and <code>console.timeEnd</code>
calls, and see where that leads us. My hypothesis is that allocating a new
vector of cells and freeing the old vector on every tick is costly, and taking
up a significant portion of our time budget.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _timer = Timer::new("Universe::tick");

    let mut next = {
        let _timer = Timer::new("allocate next cells");
        self.cells.clone()
    };

    {
        let _timer = Timer::new("new generation");
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new("free old cells");
    self.cells = next;
}
<span class="boring">}</span></code></pre></pre>
<p>Looking at the timings, it is clear that my hypothesis is incorrect: the vast
majority of time is spent actually calculating the next generation of
cells. Allocating and freeing a vector on every tick appears to have negligible
cost, surprisingly. Another reminder to always guide our efforts with profiling!</p>
<p><a href="../images/game-of-life/console-time-in-universe-tick.png"><img src="../images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>The next section requires the <code>nightly</code> compiler. It's required because of
the <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">test feature gate</a>
we're going to use for the benchmarks. Another tool we will install is <a href="https://github.com/BurntSushi/cargo-benchcmp">cargo benchcmp</a>.
It's a small utility for comparing micro-benchmarks produced by <code>cargo bench</code>.</p>
<p>Let's write a native code <code>#[bench]</code> doing the same thing that our WebAssembly
is doing, but where we can use more mature profiling tools. Here is the new
<code>wasm-game-of-life/benches/bench.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
<span class="boring">}</span></code></pre></pre>
<p>We also have to comment out all the <code>#[wasm_bindgen]</code> annotations, and the
<code>"cdylib"</code> bits from <code>Cargo.toml</code> or else building native code will fail and
have link errors.</p>
<p>With all that in place, we can run <code>cargo bench | tee before.txt</code> to compile and run our
benchmark! The <code>| tee before.txt</code> part will take the output from <code>cargo bench</code> and put in a file
called <code>before.txt</code>.</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>This also tells us where the binary lives, and we can run the benchmarks again,
but this time under our operating system's profiler. In my case, I'm running
Linux, so <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a> is the profiler I'll use:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>Loading up the profile with <code>perf report</code> shows that all of our time is spent in
<code>Universe::tick</code>, as expected:</p>
<p><a href="../images/game-of-life/bench-perf-report.png"><img src="../images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p><code>perf</code> will annotate which instructions in a function time is being spent at if
you press <code>a</code>:</p>
<p><a href="../images/game-of-life/bench-perf-annotate.png"><img src="../images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf&#39;s instruction annotation" /></a></p>
<p>This tells us that 26.67% of time is being spent summing neighboring cells'
values, 23.41% of time is spent getting the neighbor's column index, and another
15.42% of time is spent getting the neighbor's row index. Of these top three
most expensive instructions, the second and third are both costly <code>div</code>
instructions. These <code>div</code>s implement the modulo indexing logic in
<code>Universe::live_neighbor_count</code>.</p>
<p>Recall the <code>live_neighbor_count</code> definition inside
<code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
<span class="boring">}</span></code></pre></pre>
<p>The reason we used modulo was to avoid cluttering up the code with <code>if</code> branches
for the first or last row or column edge cases. But we are paying the cost of a
<code>div</code> instruction even for the most common case, when neither <code>row</code> nor <code>column</code>
is on the edge of the universe and they don't need the modulo wrapping
treatment. Instead, if we use <code>if</code>s for the edge cases and unroll this loop, the
branches <em>should</em> be very well-predicted by the CPU's branch predictor.</p>
<p>Let's rewrite <code>live_neighbor_count</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
<span class="boring">}</span></code></pre></pre>
<p>Now let's run the benchmarks again! This time output it to <code>after.txt</code>.</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>That looks a whole lot better! We can see just how much better it is with the <code>benchcmp</code> tool and the two text files we created before:</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>Wow! 7.61x speed up!</p>
<p>WebAssembly intentionally maps closely to common hardware architectures, but we
do need to make sure that this native code speed up translates into a
WebAssembly speed up as well.</p>
<p>Let's rebuild the <code>.wasm</code> with <code>wasm-pack build</code> and refresh
<a href="http://localhost:8080/">http://localhost:8080/</a>. On my machine, the page is
running at 60 frames per second again, and recording another profile with the
browser's profiler reveals that each animation frame is taking about ten
milliseconds.</p>
<p>Success!</p>
<p><a href="../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>
<p>At this point, the next lowest hanging fruit for speeding up <code>Universe::tick</code>
is removing the allocation and free. Implement double buffering of cells,
where the <code>Universe</code> maintains two vectors, never frees either of them, and
never allocates new buffers in <code>tick</code>.</p>
</li>
<li>
<p>Implement the alternative, delta-based design from the "Implementing Life"
chapter, where the Rust code returns a list of cells that changed states to
JavaScript. Does this make rendering to <code>&lt;canvas&gt;</code> faster? Can you implement
this design without allocating a new list of deltas on every tick?</p>
</li>
<li>
<p>As our profiling has shown us, 2D <code>&lt;canvas&gt;</code> rendering is not particularly
fast. Replace the 2D canvas renderer with a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> renderer. How much faster is
the WebGL version? How large can you make the universe before WebGL rendering
is a bottleneck?</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../game-of-life/interactivity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../game-of-life/code-size.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../game-of-life/interactivity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../game-of-life/code-size.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
