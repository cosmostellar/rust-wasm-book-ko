<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Game of Life 구현하기 - Rust and WebAssembly</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> 소개</a></li><li class="chapter-item expanded "><a href="../why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 왜 Rust로 WebAssembly 개발을 해야 하나요?</a></li><li class="chapter-item expanded "><a href="../background-and-concepts.html"><strong aria-hidden="true">3.</strong> 배경 지식</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> WebAssembly가 뭔가요?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 튜토리얼</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 셋업하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="../game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 규칙</a></li><li class="chapter-item expanded "><a href="../game-of-life/implementing.html" class="active"><strong aria-hidden="true">4.4.</strong> Game of Life 구현하기</a></li><li class="chapter-item expanded "><a href="../game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> Testing Life</a></li><li class="chapter-item expanded "><a href="../game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="../game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> Adding Interactivity</a></li><li class="chapter-item expanded "><a href="../game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> Time Profiling</a></li><li class="chapter-item expanded "><a href="../game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="../game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> Publishing to npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/crates.html"><strong aria-hidden="true">5.1.</strong> Crates You Should Know</a></li><li class="chapter-item expanded "><a href="../reference/tools.html"><strong aria-hidden="true">5.2.</strong> Tools You Should Know</a></li><li class="chapter-item expanded "><a href="../reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> Project Templates</a></li><li class="chapter-item expanded "><a href="../reference/debugging.html"><strong aria-hidden="true">5.4.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="../reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> Time Profiling</a></li><li class="chapter-item expanded "><a href="../reference/code-size.html"><strong aria-hidden="true">5.6.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="../reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript Interoperation</a></li><li class="chapter-item expanded "><a href="../reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> Which Crates Will Work Off-the-Shelf with WebAssembly?</a></li><li class="chapter-item expanded "><a href="../reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> How to Add WebAssembly Support to a General-Purpose Crate</a></li><li class="chapter-item expanded "><a href="../reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Deploying Rust and WebAssembly to Production</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="conways-game-of-life-구현하기"><a class="header" href="#conways-game-of-life-구현하기">Conway's Game of Life 구현하기</a></h1>
<h2 id="설계"><a class="header" href="#설계">설계</a></h2>
<p>시작하기 전에, 어떤 방식으로 설계를 해야 할지 살펴봅시다.</p>
<h3 id="무한한-세상"><a class="header" href="#무한한-세상">무한한 세상</a></h3>
<p>Game of Life는 무한한 세상에서 시작됩니다. 하지만 우리가 무한한 메모리와 컴퓨터 파워를 가지고 있지 않지는 않기 때문에, 보통은 다음 세 가지 방법 중 한 가지로 이 귀찮은 제한을 우회하게 됩니다:</p>
<ol>
<li>
<p>세상의 어떤 부분이 많은 컴퓨터 자원을 필요로 하는지 추적하고 이러한 부분을 필요할 때 확장합니다. 최악의 경우에는, 이 확장이 제한 없이 진행되고 코드가 계속해서 느려지면서 결국에는 메모리를 다 차지하게 됩니다.</p>
</li>
<li>
<p>모서리에 위치한 세포들이 가운데에 위치한 세포들과 비교해서 더 적은 이웃을 가지게 되는 사이즈가 정해져 있는 세상을 만듭니다. <a href="https://conwaylife.com/wiki/Glider">gliders</a>와 같은 무한한 패턴이 모서리에서 끝나버리게 되는 단점이 있습니다.</p>
</li>
<li>
<p>사이즈가 정해졌지만 계속해서 연결되는 우주를 만듭니다. 세상의 끝을 반대쪽 세상의 끝으로 연결시켜 세포들이 계속 이웃을 가질수 있게 합니다. 이렇게 gliders 패턴이 계속 움직일수 있게 됩니다.</p>
</li>
</ol>
<p>그러면 세 번째 방법으로 구현을 해보겠습니다.</p>
<h3 id="rust와-javascript-코드끼리-연결하기"><a class="header" href="#rust와-javascript-코드끼리-연결하기">Rust와 JavaScript 코드끼리 연결하기</a></h3>
<blockquote>
<p>⚡ 다음 내용은 이 튜토리얼에서 다루는 내용 중에서도 아주 중요한 내용입니다. 이 내용을 이해하면서 얻어갈 수 있는 부분이 많습니다!</p>
</blockquote>
<p>JavaScript는 <code>Object</code>, <code>Array</code> 그리고 <a href="https://developer.mozilla.org/ko/docs/Glossary/Node/DOM">DOM 노드 (node)</a>들이 할당되는 가비지 콜렉터가 관리하는 힙을 사용하지만, 작성하게 될 Rust 코드의 선형 메모리는 별개의 공간을 사용하게 됩니다. WebAssembly는 현재로써는 가비지 콜렉터가 관리하는 힙에 직접 접근할수 없습니다. (2018년 4월 기준으로, <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">"Interface Types" proposal</a>과 함께 변경될 전망이긴 합니다.) 반면에 JavaScript는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>나 스칼라 값 (scalar values / <code>u8</code>, <code>i32</code>, <code>f64</code>, 등...)만으로라도 이 선형 메모리를 읽고 쓸수 있습니다. 이런 내용을 기반으로 모든 WebAssembly와 JavaScript 사이의 커뮤니케이션이 구성되게 됩니다.</p>
<p><code>wasm_bindgen</code>는 이 경계를 사이로 어떻게 구조체(compound structure)들을 주고받아야 하는지 정해주는 역할을 합니다. 이러한 작업은 Rust 구조체를 박싱(boxing)하고, 쉽게 사용하기 위해 JavaScript 클래스에 포인터를 랩핑(wrapping)하고, Rust 코드에서 JavaScript 객체 테이블을 인덱싱(indexing)하는 과정을 포함합니다. <code>wasm_bindgen</code>은 매우 간편하지만, 데이터 표현 설계를 모두 대신 해주진 않습니다. 원하는 방식으로 인터페이스 설계를 구현할수 있도록 도와주는 도구 정도로 생각해주세요.</p>
<p>WebAssembly와 JavaScript 사이의 인터페이스를 설계할 때, 다음 내용들을 최적화 작업 시 고려해야 합니다:</p>
<ol>
<li>
<p><strong>JavaScript와 WebAssembly 선형 메모리 사이를 오가는 복사(copy) 최소화하기</strong>
불필요한 복사는 불필요한 오버헤드를 발생시킵니다.</p>
</li>
<li>
<p><strong>직렬화 (serializing)와 역직렬화(deserializing) 최소화하기.</strong> 복사와 마찬가지로, 직렬화와 역직렬화도 오버헤드를 발생시킬수 있고, 이러한 작업이 복사도 자주 발생시키게 됩니다. 한곳에서 모든 직렬화 작업을 하는 대신 일반적으로 WebAssembly 선형 메모리의 알려진 위치로 <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque handle</a>들을 넘기는 방식으로 많은 오버헤드를 없앨수 있게 됩니다. <code>wasm_bindgen</code>을 통해 JavaScript의 <code>Object</code>, 박싱된 Rust 구조체(<code>struct</code>)와 사용하는 opaque handle들을 더 쉽게 정의하고 관리할 수 있습니다.</p>
</li>
</ol>
<p>대부분의 경우에는, JavaScript와 WebAssembly를 오갈 때 사이즈가 크고 오래 살아있어야 하는 자료 구조를 WebAssembly 선형 메모리에 두고, 이러한 값들을 JavaScript에서 opaque handle로써 노출 시키는 것이 좋은 인터페이스 설계입니다. JavaScript가 이러한 opaque handle를 통해 WebAssembly 함수를 부르고, 데이터를 변형시키고, 무거운 컴퓨팅 작업을 하고, 값을 검색하고, 최종적으로 작은 사이즈의 복사할수 있는 값을 반환(return)합니다. 작은 값만 반환하면 JavaScript 가비지 콜렉터가 관리하는 힙과 WebAssembly 선형 메모리 사이의 모든 값들을 앞뒤로 복사하고 직렬화할 필요가 없게 됩니다.</p>
<h3 id="rust와-javascript를-구현하는-프로그램에서-조작하기"><a class="header" href="#rust와-javascript를-구현하는-프로그램에서-조작하기">Rust와 JavaScript를 구현하는 프로그램에서 조작하기</a></h3>
<p>위험한 사례를 살펴보는 것으로 시작해봅시다. 매 틱마다 세상을 WebAssembly에서 불러오거나 가져오기 위해 복사하지 않아야 하고, 세포 하나씩 객체를 모두 할당하거나 경계를 오가면서 읽고 쓰는 것도 좋지 않습니다.</p>
<p>그러면 어떻게 구현하는 게 좋을까요? 죽은 세포를 <code>0</code>로 나타내고 살아있는 세포를 <code>1</code>로 나타내는 식으로 세포들을 각각 1 byte 값으로 나타낼수 있는데, WebAssembly 선형 메모리에 1차원 배열로 나타내봅시다.</p>
<p>4 x 4 사이즈의 우주를 메모리 이미지로 표현해보겠습니다:</p>
<p><img src="../images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>주어진 열과 행에 해당하는 배열 인덱스를 찾을 때는 이 공식을 사용할 수 있습니다:</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>세포들을 JavaScript에 노출시킬때 여러가지 방법을 사용해볼수 있는데, 우선은 Rust <code>String</code> 타입의 값으로 세포들을 문자로 표시할수 있도록 <code>Universe</code> 타입에 <code>std::fmt::Display</code> 트레이트(trait)를 구현해주도록 합시다. 이 트레이트를 통해 Rust <code>String</code> 타입의 값을 WebAssembly 선형 메모리에서 JavaScript 가비지 콜렉터가 관리하는 힙으로 복사할 수 있게 됩니다. 그 다음, 복사된 값을 HTML <code>textConent</code>에 표시해보도록 하겠습니다. 이 챕터 후반에서는 이 구현에 덧붙여서 세포들을 힙에 복사하지 않도록 해보고 세포들을 <code>&lt;canvas&gt;</code>에 표시할 예정입니다.</p>
<p><em>하나 더 대신 해볼법한 설계가 있는데, 세상 전체를 노출시키지 않고 매 틱마다 상태가 바뀌게 되는 세포들을 목록으로 만들어서 Rust 코드에서 JavaScript로 반환을 해볼수도 있습니다. 이런 방법으로, JavaScript 코드에서 세상 전체를 순회할 필요 없이 일부만 순회할수 있게 됩니다. 단점으로는, 이 델타 기반 (delta-based)의 설계는 구현하기가 조금 더 어렵습니다.</em></p>
<h2 id="rust-코드-구현하기"><a class="header" href="#rust-코드-구현하기">Rust 코드 구현하기</a></h2>
<p>직전 챕터에서 초기 프로젝트 템플릿을 클론했는데, 이 템플릿을 수정해보도록 합시다.</p>
<p><code>alert</code>를 불러오는 줄과 <code>greet</code> 함수를 <code>wasm-game-of-life/src/lib.rs</code> 파일에서 지워보고, 세포 타입 정의를 대신 추가해 주는 것으로 시작해보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
<span class="boring">}</span></code></pre></pre>
<p>각 세포가 1 byte 사이즈로 표현되도록 해야하기 때문에 <code>#[repr(u8)]</code>을 잊지 않고 붙여주도록 하고, 세포 주변에 살아있는 이웃들을 쉽게 셀수 있도록, <code>0</code>를 <code>Dead</code>로, <code>1</code>을 <code>Alive</code>로 정해주는 것도 중요합니다.</p>
<p>그 다음, 세상을 정의해봅시다. 세상을 나타내는 구조체는 너비와 높이, 세포들을 나타내는 <code>width * height</code> 길이의 벡터(vector)를 필드로 가지게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>이전에 설명한 내용대로 주어진 행과 열을 세포 벡터의 인덱스로 변환하여 사용할수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>세포의 다음 상태를 계산하려면 몇 개의 이웃이 살아있는지 확인해야 합니다. 이 내용을 토대로 <code>live_neighbor_count</code> 메서드를 작성해봅시다!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>live_neighbor_count</code> 메서드는 델타값과 나머지 값을 확인해서 세상의 끝에서 발생할 수 있는 예외를 <code>if</code>문으로 처리합니다. <code>-1</code>의 델타를 적용할 때, <code>self.height -1</code>을 추가해서 <code>1</code>을 빼는 대신 나머지 값을 계속 처리하게 합니다. <code>row</code>와 <code>column</code>은 <code>0</code>이 될수 있고, 이 값에서 <code>1</code>을 뺄려고 할때, unsigned integer underflow가 발생하게 됩니다.</p>
<p>이제 현재 세대를 기반으로 다음 세대를 처리하는데 필요한 준비가 완료됐습니다! <code>match</code> 문을 사용해서 보기 명확하게 게임의 규칙을 나타내봅시다. 추가로, 틱이 일어날 때 JavaScript가 컨트롤하도록 할 것이기 때문에, <code>#[wasm_bindgen]</code> 블럭을 추가해서 이 메서드를 JavaScript 코드에 노출시켜보도록 하겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메서드, JavaScript로 보낼수 있게 함.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // 규칙 1: 인구 부족으로 2개 미만의 이웃을 가진 세포는 죽게 됩니다. 
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // 규칙 2: 2개 혹은 3개의 이웃을 가진 세포는 다음 세대에서 계속 살아있습니다.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: 과잉 인구로 3개 초과의 이웃을 가진 모든 세포는 죽게 됩니다.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // 규칙 4: 세포 증식으로 정확히 3개의 이웃을 가진 세포는 살아나게 됩니다.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // 규칙이 적용되지 않는 세포들의 상태는 그대로 유지되게 됩니다.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>지금까지 세상의 상태는 세포들의 벡터로 표시됐습니다. 조금 더 사람이 읽기 쉽도록 텍스트 렌더러 (text renderer)를 구현해보도록 합시다. 세상을 한줄 한줄씩 텍스트로 표현을 해보는데, 살아있는 세포들을 유니코드 문자 <code>◼</code> ("black medium square")로 나타내고 죽은 세포들을 <code>◻</code>
(a "white medium square")로 표현하겠습니다.</p>
<p>Rust 스탠다드 라이브러리의 <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> 트레이트를 구현해서 사람이 읽기 쉬운 방식으로 포맷할수 있도록 메서드를 추가해봅시다. 이 트레이트를 구현하면 자동적으로 Universe의 인스턴스(instance)들이 <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> 메서드를 사용할수 있게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>마침내, <code>render</code> 메서드와 함께 생성자를 정의해서 세포들이 살아나고 죽어가는 신기한 세상을 생성할 수 있도록 해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메서드, JavaScript로 보낼수 있게 함.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>드디어 Game of Life의 Rust 코드 구현이 끝났습니다!</p>
<p>이제 <code>wasm-game-of-life</code> 디렉토리에서 <code>wasm-pack build</code>를 실행하여 WebAssembly 파일을 다시 컴파일 해주세요.</p>
<h2 id="javascript로-페이지-렌더링하기"><a class="header" href="#javascript로-페이지-렌더링하기">JavaScript로 페이지 렌더링하기</a></h2>
<p><code>wasm-game-of-life/www/index.html</code>에 <code>&lt;pre&gt;</code> 요소를 추가해서 세상을 렌더링 해봅시다. <code>&lt;pre&gt;</code> 요소를 <code>&lt;script&gt;</code> 태그 바로 위에 추가해주세요:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id="game-of-life-canvas"&gt;&lt;/pre&gt;
  &lt;script src="./bootstrap.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>추가로, <code>&lt;pre&gt;</code> 가 웹사이트 중간에 표시될수 있도록 CSS flex box를 사용해봅시다. <code>wasm-game-of-life/www/index.html</code> 파일을 열고 <code>&lt;head&gt;</code> 내에 <code>&lt;style&gt;</code> 태그를 추가해주세요:</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<p><code>wasm-game-of-life/www/index.js</code> 파일 최상단에 기존 <code>greet</code> 함수를 지우고 <code>Universe</code>를 불러오는 줄을 추가해주세요.</p>
<pre><code class="language-js">import { Universe } from "wasm-game-of-life";
</code></pre>
<p><code>&lt;pre&gt;</code> 요소를 <code>pre</code> 상수에 담은 다음 새 우주를 시작해봅시다.</p>
<pre><code class="language-js">const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();
</code></pre>
<p>이 JavaScript 함수는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code> 루프</a>로 실행해서 매 반복마다 업데이트된 세상을 <code>&lt;pre&gt;</code>에 반영하고 <code>Universe::tick</code>을 호출합니다.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>렌더링 처리를 시작하려면 다음 코드를 <code>renderLoop</code> 함수 밖에 추가해서 렌더링 루프를 시작해주세요:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>다시 한번 (<code>npm run</code>을 <code>wasm-game-of-life/www</code> 디렉토리에서 실행한) 개발 서버가 아직 구동중인지 확인해주세요. <a href="http://localhost:8080/">http://localhost:8080/</a> 페이지를 열면 다음 내용을 확인할수 있습니다:</p>
<p><a href="../images/game-of-life/initial-game-of-life-pre.png"><img src="../images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<h2 id="메모리에서-바로-캔버스로-렌더링하기"><a class="header" href="#메모리에서-바로-캔버스로-렌더링하기">메모리에서 바로 캔버스로 렌더링하기</a></h2>
<p>Rust 코드에서 <code>String</code>을 생성 (및 할당)하고 <code>wasm-bindgen</code>로 이 생성한 값을 유효한 JavaScript 문자열로 변환하게 되면 세포들을 불필요하게 복사하게 됩니다. JavaScript 코드에서 세상의 너비와 높이를 이미 알고 있고, 세포를 만드는 처리가 이루어지는 WebAssembly 선형 메모리를 읽을 수 있기 때문에, <code>render</code> 메서드를 수정하여 <code>cells</code> 배열의 시작을 가리키는 포인터를 반환하도록 하겠습니다.</p>
<p>그리고 유니코드 문자를 렌더링하지 않고 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a> 를 대신 사용해봅시다. 이 API를 이 부분 이후부터 계속 사용하겠습니다.</p>
<p><code>wasm-game-of-life/www/index.html</code> 파일에서 전에 추가한 <code>&lt;pre&gt;</code>를 지우고 렌더링에 사용할 <code>&lt;canvas&gt;</code>를 추가해줍시다. (<code>&lt;body&gt;</code> 태그 내에서 JavaScript 코드를 시작시키는 <code>&lt;script&gt;</code> 태그 위에 추가돼야 합니다.)</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id="game-of-life-canvas"&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Rust로 구현한 코드에서 필요한 정보를 얻어올수 있도록 위해 세상의 넓이, 너비, 세포 배열을 가리키는 포인터를 반환하는 getter 함수들을 조금 더 만들어보겠습니다. 이 함수들도 JavaScript 코드로 노출시켜야 하니 잘 확인해주고 <code>wasm-game-of-life/src/lib.rs</code> 파일에 다음 코드를 추가해줍시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public 메서드, JavaScript로 보낼수 있게 함.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>그 다음, <code>wasm-game-of-life/www/index.js</code> 파일에 <code>wasm-game-of-life</code> 모듈에서 <code>Cell</code>을 불러오는 줄을 추가해주고 캔버스를 렌더링할때 사용할 상수 몇가지를 정의해줍시다.</p>
<pre><code class="language-js">import { Universe, Cell } from "wasm-game-of-life";

const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";
</code></pre>
<p>이제 <code>&lt;pre&gt;</code> 태그의 <code>textContent</code> 대신에 <code>&lt;canvas&gt;</code>를 업데이트 할수 있도록 JavaScript 나머지 코드를 다시 작성해봅시다:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>To draw the grid between cells, we draw a set of equally-spaced horizontal
lines, and a set of equally-spaced vertical lines. These lines criss-cross to
form the grid.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>We can directly access WebAssembly's linear memory via <code>memory</code>, which is
defined in the raw wasm module <code>wasm_game_of_life_bg</code>. To draw the cells, we
get a pointer to the universe's cells, construct a <code>Uint8Array</code> overlaying the
cells buffer, iterate over each cell, and draw a white or black rectangle
depending on whether the cell is dead or alive, respectively. By working with
pointers and overlays, we avoid copying the cells across the boundary on every
tick.</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>To start the rendering process, we'll use the same code as above to start the
first iteration of the rendering loop:</p>
<pre><code class="language-js">drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
</code></pre>
<p>Note that we call <code>drawGrid()</code> and <code>drawCells()</code> here <em>before</em> we call
<code>requestAnimationFrame()</code>. The reason we do this is so that the <em>initial</em> state
of the universe is drawn before we make modifications. If we instead simply
called <code>requestAnimationFrame(renderLoop)</code>, we'd end up with a situation where
the first frame that was drawn would actually be <em>after</em> the first call to
<code>universe.tick()</code>, which is the second "tick" of the life of these cells.</p>
<h2 id="it-works"><a class="header" href="#it-works">It Works!</a></h2>
<p>Rebuild the WebAssembly and bindings glue by running this command from within
the root <code>wasm-game-of-life</code> directory:</p>
<pre><code>wasm-pack build
</code></pre>
<p>Make sure your development server is still running. If it isn't, start it again
from within the <code>wasm-game-of-life/www</code> directory:</p>
<pre><code>npm run start
</code></pre>
<p>If you refresh <a href="http://localhost:8080/">http://localhost:8080/</a>, you should be
greeted with an exciting display of life!</p>
<p><a href="../images/game-of-life/initial-game-of-life.png"><img src="../images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>As an aside, there is also a really neat algorithm for implementing the Game of
Life called <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>. It uses
aggressive memoizing and can actually get <em>exponentially faster</em> to compute
future generations the longer it runs! Given that, you might be wondering why we
didn't implement hashlife in this tutorial. It is out of scope for this text,
where we are focusing on Rust and WebAssembly integration, but we highly
encourage you to go learn about hashlife on your own!</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>
<p>Initialize the universe with a single space ship.</p>
</li>
<li>
<p>Instead of hard-coding the initial universe, generate a random one, where each
cell has a fifty-fifty chance of being alive or dead.</p>
<p><em>Hint: use <a href="https://crates.io/crates/js-sys">the <code>js-sys</code> crate</a> to import
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">the <code>Math.random</code> JavaScript
function</a>.</em></p>
<details>
  <summary>Answer</summary>
  *First, add `js-sys` as a dependency in `wasm-game-of-life/Cargo.toml`:*
<pre><code class="language-toml"># ...
[dependencies]
js-sys = "0.3"
# ...
</code></pre>
<p><em>Then, use the <code>js_sys::Math::random</code> function to flip a coin:</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys;

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Alive...
} else {
    // Dead...
}
<span class="boring">}</span></code></pre></pre>
</details>
</li>
<li>
<p>Representing each cell with a byte makes iterating over cells easy, but it
comes at the cost of wasting memory. Each byte is eight bits, but we only
require a single bit to represent whether each cell is alive or dead. Refactor
the data representation so that each cell uses only a single bit of space.</p>
<details>
  <summary>Answer</summary>
<p>In Rust, you can use <a href="https://crates.io/crates/fixedbitset">the <code>fixedbitset</code> crate and its <code>FixedBitSet</code>
type</a> to represent cells instead of
<code>Vec&lt;Cell&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you also added the dependency to Cargo.toml!
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}
<span class="boring">}</span></code></pre></pre>
<p>The Universe constructor can be adjusted the following way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    let width = 64;
    let height = 64;

    let size = (width * height) as usize;
    let mut cells = FixedBitSet::with_capacity(size);

    for i in 0..size {
        cells.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Universe {
        width,
        height,
        cells,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To update a cell in the next tick of the universe, we use the <code>set</code> method
of <code>FixedBitSet</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>next.set(idx, match (cell, live_neighbors) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (otherwise, _) =&gt; otherwise
});
<span class="boring">}</span></code></pre></pre>
<p>To pass a pointer to the start of the bits to JavaScript, you can convert
the <code>FixedBitSet</code> to a slice and then convert the slice to a pointer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe {
    // ...

    pub fn cells(&amp;self) -&gt; *const u32 {
        self.cells.as_slice().as_ptr()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In JavaScript, constructing a <code>Uint8Array</code> from Wasm memory is the same as
before, except that the length of the array is not <code>width * height</code> anymore,
but <code>width * height / 8</code> since we have a cell per bit rather than per byte:</p>
<pre><code class="language-js">const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
</code></pre>
<p>Given an index and <code>Uint8Array</code>, you can determine whether the
<em>n<sup>th</sup></em> bit is set with the following function:</p>
<pre><code class="language-js">const bitIsSet = (n, arr) =&gt; {
  const byte = Math.floor(n / 8);
  const mask = 1 &lt;&lt; (n % 8);
  return (arr[byte] &amp; mask) === mask;
};
</code></pre>
<p>Given all that, the new version of <code>drawCells</code> looks like this:</p>
<pre><code class="language-js">const drawCells = () =&gt; {
  const cellsPtr = universe.cells();

  // This is updated!
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      // This is updated!
      ctx.fillStyle = bitIsSet(idx, cells)
        ? ALIVE_COLOR
        : DEAD_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../game-of-life/rules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../game-of-life/testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../game-of-life/rules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../game-of-life/testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
